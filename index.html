<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO Annotation Tool</title>
    <style>
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent: #3ea6ff;
            --accent-hover: #2a96ef;
            --error: #ff5252;
            --success: #4caf50;
            --handle-size: 15px;
            --box-border-width: 1px;
            --box-selected-border-width: 2px;
            --box-fill-opacity: 0.35;
            --box-selected-fill-opacity: 0.45;
            --label-height: 28px;
            --label-font-size: 15px;
            --label-padding: 8px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 20px;
        }
        
        h1, h2, h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        
        .btn {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--accent-hover);
        }
        
        .btn-secondary {
            background-color: var(--bg-secondary);
            border: 1px solid var(--accent);
            color: var(--accent);
        }
        
        .btn-secondary:hover {
            background-color: rgba(62, 166, 255, 0.1);
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .canvas-container {
            position: relative;
            overflow: auto;
            margin-bottom: 16px;
            background-color: var(--bg-secondary);
            border-radius: 4px;
            height: 60vh; /* Updated for responsiveness */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.4);
        }
        
        #imageCanvas {
            display: block;
            cursor: crosshair;
        }
        
        #imageCanvas.drawing {
            cursor: crosshair;
        }
        
        #imageCanvas.moving {
            cursor: move;
        }
        
        #imageCanvas.resizing {
            cursor: nwse-resize;
        }
        
        .panel {
            background-color: var(--bg-secondary);
            padding: 16px;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        
        .flex-container {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .sidebar {
            flex: 1;
            min-width: 250px;
        }
        
        .main-content {
            flex: 3;
            min-width: 500px;
        }
        
        .image-list {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .image-item {
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 40px; /* Added for touch-friendliness */
        }
        
        .image-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .image-item.active {
            background-color: rgba(62, 166, 255, 0.2);
            border-left: 3px solid var(--accent);
        }
        
        .annotation-item {
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .class-selector {
            margin-bottom: 16px;
        }
        
        #classLabel {
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .class-btn {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            margin: 2px 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--accent);
            color: var(--text-primary);
            cursor: pointer;
            width: 100%;
            text-align: left;
            min-height: 40px; /* Added for touch-friendliness */
        }
        
        .class-btn span {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            display: inline-block;
        }
        
        .class-btn.selected {
            background-color: var(--accent);
            color: white;
        }
        
        .notification {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 16px;
            display: none;
        }
        
        .notification.success {
            background-color: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--success);
            color: var(--success);
        }
        
        .notification.error {
            background-color: rgba(255, 82, 82, 0.2);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .file-input-label {
            display: block;
            background-color: var(--accent);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            text-align: center;
            transition: background-color 0.2s;
        }
        
        .file-input-label:hover {
            background-color: var(--accent-hover);
        }
        
        .annotation-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
            
            .sidebar, .main-content {
                width: 100%;
                min-width: 0; /* Override min-width for small screens */
            }
        }
        
        .box-overlay {
            position: absolute;
            pointer-events: none;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        @keyframes selectedBoxPulse {
            0% { box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.7); }
            50% { box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.7); }
            100% { box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.7); }
        }
        
        .handle {
            position: absolute;
            width: var(--handle-size);
            height: var(--handle-size);
            background-color: white;
            border: 2px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .handle.top-left { cursor: nwse-resize; }
        .handle.top-right { cursor: nesw-resize; }
        .handle.bottom-left { cursor: nesw-resize; }
        .handle.bottom-right { cursor: nwse-resize; }
        .handle.top-middle { cursor: ns-resize; }
        .handle.bottom-middle { cursor: ns-resize; }
        .handle.middle-left { cursor: ew-resize; }
        .handle.middle-right { cursor: ew-resize; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>YOLO Annotation Tool</h1>
            <div>
                <button id="exportBtn" class="btn">Export Annotations</button>
                <button id="resetBtn" class="btn">Reset</button>
            </div>
        </div>
        
        <div id="notification" class="notification"></div>
        
        <div class="flex-container">
            <div class="sidebar">
                <div class="panel">
                    <h2>Images</h2>
                    <div class="btn-group">
                        <button id="pickFolderBtn" class="file-input-label">Import Images</button>
                    </div>
                    <ul id="imageList" class="image-list"></ul>
                </div>
                
                <div class="panel">
                    <h2>Class Selection</h2>
                    <div class="class-selector">
                        <p id="classLabel">Select class for new boxes</p>
                        <div id="classButtons"></div>
                    </div>
                </div>
            </div>
            
            <div class="main-content">
                <div class="panel">
                    <h2>Image Annotation</h2>
                    <p class="label">Tap and drag to draw boxes; tap to select; Delete key to remove selected (desktop only); Drag handles to resize; Drag box to move</p>
                    <div class="canvas-container">
                        <canvas id="imageCanvas"></canvas>
                    </div>
                    <div class="btn-group">
                        <button id="deleteLastBtn" class="btn btn-secondary">Delete Last Box</button>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Annotations</h2>
                    <div id="annotationList" class="annotation-list"></div>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // DOM Elements
        const pickFolderBtn = document.getElementById('pickFolderBtn');
        const imageList = document.getElementById('imageList');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const classLabel = document.getElementById('classLabel');
        const classButtonsDiv = document.getElementById('classButtons');
        const exportBtn = document.getElementById('exportBtn');
        const resetBtn = document.getElementById('resetBtn');
        const deleteLastBtn = document.getElementById('deleteLastBtn');
        const annotationList = document.getElementById('annotationList');
        const notification = document.getElementById('notification');
        const fileInput = document.getElementById('fileInput');

        // State Variables
        const classNames = {
            '0': 'beard', '1': 'mustache', '2': 'glasses', '3': 'straight hair', '4': 'curly hair',
            '5': 'wavy hair', '6': 'bald', '7': 'acne', '8': 'redness', '9': 'dark spots',
            '10': 'ue'
        };
        const classes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        let currentClass = '0';
        let dirHandle = null;
        let imageKeys = [];
        let images = {};
        let annotations = {};
        let history = {};
        let currentImageKey = null;
        let selectedBoxIndex = -1;
        let isDrawing = false;
        let isResizing = false;
        let isMoving = false;
        let startX, startY;
        let initialBox;
        let resizingHandle;
        let previewBox = null;
        let initialMouseX, initialMouseY;
        const handleSize = 15;
        const minBoxSize = 10;

        // Create Class Buttons
        classes.forEach(classId => {
            const button = document.createElement('button');
            button.className = 'class-btn';
            button.dataset.class = classId;
            const swatch = document.createElement('span');
            swatch.style.backgroundColor = getColorForClass(classId);
            button.appendChild(swatch);
            button.appendChild(document.createTextNode(classNames[classId]));
            button.addEventListener('click', () => handleClassButtonClick(classId));
            classButtonsDiv.appendChild(button);
        });

        // Highlight Initial Class
        highlightClassButton(currentClass);

        // Event Listeners
        pickFolderBtn.addEventListener('click', async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    dirHandle = await window.showDirectoryPicker();
                    loadImagesFromDirectory();
                } catch (error) {
                    console.error('Error picking directory:', error);
                    showNotification('Failed to pick directory.', 'error');
                }
            } else {
                fileInput.click();
            }
        });
        fileInput.addEventListener('change', handleFileSelect);
        imageCanvas.addEventListener('mousedown', handleMouseDown);
        imageCanvas.addEventListener('mousemove', handleMouseMove);
        imageCanvas.addEventListener('mouseup', handleMouseUp);
        imageCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        imageCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        imageCanvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        exportBtn.addEventListener('click', exportAnnotations);
        resetBtn.addEventListener('click', reset);
        deleteLastBtn.addEventListener('click', deleteLastAnnotation);
        window.addEventListener('resize', setCanvasDisplaySize);
        document.addEventListener('keydown', handleKeyDown);

        // File Handling Functions
        async function loadImagesFromDirectory() {
            imageKeys = [];
            images = {};
            annotations = {};
            history = {};

            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(jpg|jpeg|png|gif)$/i)) {
                    const file = await entry.getFile();
                    const imageKey = entry.name;
                    imageKeys.push(imageKey);

                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.src = e.target.result;
                        img.onload = function() {
                            images[imageKey] = {
                                name: entry.name,
                                element: img,
                                width: img.width,
                                height: img.height
                            };
                            const savedAnnotations = localStorage.getItem('annotations_' + imageKey);
                            annotations[imageKey] = savedAnnotations ? JSON.parse(savedAnnotations) : [];
                            history[imageKey] = { undoStack: [], redoStack: [] };
                            updateImageList();
                            if (currentImageKey === null && imageKeys.length > 0) {
                                selectImage(imageKeys[0]);
                            }
                        };
                    };
                    reader.readAsDataURL(file);
                }
            }
            showNotification('Folder loaded successfully!', 'success');
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length === 0) return;

            imageKeys = [];
            images = {};
            annotations = {};
            history = {};

            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const imageKey = file.name;
                    imageKeys.push(imageKey);
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.src = e.target.result;
                        img.onload = function() {
                            images[imageKey] = {
                                name: file.name,
                                element: img,
                                width: img.width,
                                height: img.height
                            };
                            const savedAnnotations = localStorage.getItem('annotations_' + imageKey);
                            annotations[imageKey] = savedAnnotations ? JSON.parse(savedAnnotations) : [];
                            history[imageKey] = { undoStack: [], redoStack: [] };
                            updateImageList();
                            if (currentImageKey === null && imageKeys.length > 0) {
                                selectImage(imageKeys[0]);
                            }
                        };
                    };
                    reader.readAsDataURL(file);
                }
            });
            showNotification('Images loaded successfully!', 'success');
            e.target.value = ''; // Reset file input
        }

        // Canvas Size Adjustment
        function setCanvasDisplaySize() {
            if (!currentImageKey) return;
            const container = document.querySelector('.canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const image = images[currentImageKey];
            const imageAspectRatio = image.width / image.height;
            const containerAspectRatio = containerWidth / containerHeight;

            let displayWidth, displayHeight;
            if (imageAspectRatio > containerAspectRatio) {
                displayWidth = containerWidth;
                displayHeight = containerWidth / imageAspectRatio;
            } else {
                displayHeight = containerHeight;
                displayWidth = containerHeight * imageAspectRatio;
            }

            imageCanvas.style.width = displayWidth + 'px';
            imageCanvas.style.height = displayHeight + 'px';
        }

        // Image List Management
        function updateImageList() {
            imageList.innerHTML = '';
            imageKeys.forEach((key) => {
                const li = document.createElement('li');
                li.className = 'image-item' + (key === currentImageKey ? ' active' : '');
                li.textContent = key;
                li.addEventListener('click', () => selectImage(key));

                const annotationCount = document.createElement('span');
                annotationCount.textContent = annotations[key] ? annotations[key].length : '0';
                li.appendChild(annotationCount);

                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.className = 'btn btn-secondary';
                removeBtn.style.marginLeft = '10px';
                removeBtn.addEventListener('click', () => removeImage(key));

                li.appendChild(removeBtn);
                imageList.appendChild(li);
            });
        }

        async function removeImage(key) {
            if (dirHandle) {
                if (!confirm(`Are you sure you want to delete the image file "${key}" from your device? This cannot be undone.`)) return;
                try {
                    await dirHandle.removeEntry(key);
                    showNotification(`Image "${key}" deleted from device.`, 'success');
                } catch (error) {
                    console.error('Error deleting image:', error);
                    showNotification('Failed to delete image from device.', 'error');
                    return;
                }
            } else {
                if (!confirm(`Are you sure you want to remove the image "${key}" from the list?`)) return;
                showNotification(`Image "${key}" removed from the list.`, 'success');
            }

            delete images[key];
            const index = imageKeys.indexOf(key);
            imageKeys.splice(index, 1);
            localStorage.removeItem('annotations_' + key);

            if (currentImageKey === key) {
                if (imageKeys.length > 0) {
                    const nextIndex = index < imageKeys.length ? index : index - 1;
                    selectImage(imageKeys[nextIndex]);
                } else {
                    currentImageKey = null;
                    ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                    updateAnnotationList();
                }
            }
            updateImageList();
        }

        function selectImage(key) {
            currentImageKey = key;
            selectedBoxIndex = -1;
            const image = images[key];

            imageCanvas.width = image.width;
            imageCanvas.height = image.height;
            setCanvasDisplaySize();

            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            ctx.drawImage(image.element, 0, 0);

            if (annotations[key]) {
                drawAnnotations();
            }

            updateImageList();
            updateAnnotationList();
            selectBox(-1);
        }

        // Interaction Handlers
        function handleMouseDown(e) {
            if (!currentImageKey) return;
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;
            startInteraction(canvasX, canvasY);
        }

        function handleMouseMove(e) {
            if (!currentImageKey) return;
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;
            moveInteraction(canvasX, canvasY);
        }

        function handleMouseUp(e) {
            if (!currentImageKey) return;
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;
            endInteraction(canvasX, canvasY);
        }

        function handleTouchStart(e) {
            e.preventDefault();
            if (!currentImageKey) return;
            const touch = e.touches[0];
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const canvasX = (touch.clientX - rect.left) * scaleX;
            const canvasY = (touch.clientY - rect.top) * scaleY;
            startInteraction(canvasX, canvasY);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!currentImageKey) return;
            const touch = e.touches[0];
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const canvasX = (touch.clientX - rect.left) * scaleX;
            const canvasY = (touch.clientY - rect.top) * scaleY;
            moveInteraction(canvasX, canvasY);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (!currentImageKey) return;
            const touch = e.changedTouches[0];
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            const canvasX = (touch.clientX - rect.left) * scaleX;
            const canvasY = (touch.clientY - rect.top) * scaleY;
            endInteraction(canvasX, canvasY);
        }

        function startInteraction(x, y) {
            startX = x;
            startY = y;
            if (selectedBoxIndex >= 0) {
                const box = annotations[currentImageKey][selectedBoxIndex];
                const handles = getHandles(box);
                let onHandle = false;
                handles.forEach(handle => {
                    if (isPointInHandle(x, y, handle)) {
                        onHandle = true;
                        resizingHandle = handle.type;
                        isResizing = true;
                        initialBox = JSON.parse(JSON.stringify(box));
                        initialMouseX = x;
                        initialMouseY = y;
                    }
                });
                if (!onHandle && isPointInBox(x, y, box)) {
                    isMoving = true;
                    initialBox = JSON.parse(JSON.stringify(box));
                    initialMouseX = x;
                    initialMouseY = y;
                } else if (!onHandle) {
                    selectBox(-1);
                    isDrawing = true;
                }
            } else {
                isDrawing = true;
                for (let i = annotations[currentImageKey].length - 1; i >= 0; i--) {
                    const box = annotations[currentImageKey][i];
                    if (isPointInBox(x, y, box)) {
                        selectBox(i);
                        isDrawing = false;
                        break;
                    }
                }
            }
        }

        function moveInteraction(x, y) {
            if (isResizing) {
                const box = annotations[currentImageKey][selectedBoxIndex];
                const image = images[currentImageKey];
                const deltaX = x - initialMouseX;
                const deltaY = y - initialMouseY;

                if (resizingHandle === 'bottom-right') {
                    let newWidth = initialBox.width + deltaX;
                    let newHeight = initialBox.height + deltaY;
                    newWidth = Math.max(minBoxSize, Math.min(newWidth, image.width - box.x));
                    newHeight = Math.max(minBoxSize, Math.min(newHeight, image.height - box.y));
                    box.width = newWidth;
                    box.height = newHeight;
                } else if (resizingHandle === 'top-left') {
                    let newX = initialBox.x + deltaX;
                    let newY = initialBox.y + deltaY;
                    newX = Math.max(0, Math.min(newX, initialBox.x + initialBox.width - minBoxSize));
                    newY = Math.max(0, Math.min(newY, initialBox.y + initialBox.height - minBoxSize));
                    box.width = initialBox.x + initialBox.width - newX;
                    box.height = initialBox.y + initialBox.height - newY;
                    box.x = newX;
                    box.y = newY;
                } else if (resizingHandle === 'top-right') {
                    let newY = initialBox.y + deltaY;
                    let newWidth = initialBox.width + deltaX;
                    newY = Math.max(0, Math.min(newY, initialBox.y + initialBox.height - minBoxSize));
                    newWidth = Math.max(minBoxSize, Math.min(newWidth, image.width - box.x));
                    box.height = initialBox.y + initialBox.height - newY;
                    box.width = newWidth;
                    box.y = newY;
                } else if (resizingHandle === 'bottom-left') {
                    let newX = initialBox.x + deltaX;
                    let newHeight = initialBox.height + deltaY;
                    newX = Math.max(0, Math.min(newX, initialBox.x + initialBox.width - minBoxSize));
                    newHeight = Math.max(minBoxSize, Math.min(newHeight, image.height - box.y));
                    box.width = initialBox.x + initialBox.width - newX;
                    box.height = newHeight;
                    box.x = newX;
                }
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(image.element, 0, 0);
                drawAnnotations();
            } else if (isMoving) {
                const box = annotations[currentImageKey][selectedBoxIndex];
                const image = images[currentImageKey];
                let newX = initialBox.x + (x - initialMouseX);
                let newY = initialBox.y + (y - initialMouseY);
                newX = Math.max(0, Math.min(newX, image.width - box.width));
                newY = Math.max(0, Math.min(newY, image.height - box.height));
                box.x = newX;
                box.y = newY;
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(image.element, 0, 0);
                drawAnnotations();
            } else if (isDrawing) {
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(images[currentImageKey].element, 0, 0);
                drawAnnotations();

                const classId = currentClass;
                const boxColor = getColorForClass(classId);
                const boxX = Math.min(startX, x);
                const boxY = Math.min(startY, y);
                const width = Math.abs(x - startX);
                const height = Math.abs(y - startY);

                previewBox = { classId, x: boxX, y: boxY, width, height };
                ctx.strokeStyle = boxColor;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.strokeRect(boxX, boxY, width, height);
                ctx.setLineDash([]);
                ctx.fillStyle = boxColor.replace('hsl', 'hsla').replace(')', ', 0.35)');
                ctx.fillRect(boxX, boxY, width, height);
            }
        }

        function endInteraction(x, y) {
            if (isResizing || isMoving) {
                saveState();
                saveAnnotations();
                updateAnnotationList();
                isResizing = false;
                isMoving = false;
            } else if (isDrawing) {
                let boxX = Math.min(startX, x);
                let boxY = Math.min(startY, y);
                let width = Math.abs(x - startX);
                let height = Math.abs(y - startY);

                const image = images[currentImageKey];
                boxX = Math.max(0, boxX);
                boxY = Math.max(0, boxY);
                width = Math.min(image.width - boxX, width);
                height = Math.min(image.height - boxY, height);

                if (width > 5 && height > 5) {
                    const classId = currentClass;
                    const box = { classId, x: boxX, y: boxY, width, height };
                    addBox(box);
                } else {
                    drawAnnotations();
                }
                isDrawing = false;
                previewBox = null;
            }
        }

        // Utility Functions
        function isPointInBox(x, y, box) {
            return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
        }

        function getHandles(box) {
            return [
                { x: box.x, y: box.y, type: 'top-left' },
                { x: box.x + box.width, y: box.y, type: 'top-right' },
                { x: box.x, y: box.y + box.height, type: 'bottom-left' },
                { x: box.x + box.width, y: box.y + box.height, type: 'bottom-right' }
            ];
        }

        function isPointInHandle(x, y, handle) {
            const halfSize = handleSize / 2;
            return x >= handle.x - halfSize && x <= handle.x + halfSize && y >= handle.y - halfSize && y <= handle.y + halfSize;
        }

        function drawAnnotations() {
            if (!annotations[currentImageKey]) return;

            annotations[currentImageKey].forEach((box, index) => {
                const classId = box.classId;
                const boxColor = getColorForClass(classId);
                const isSelected = index === selectedBoxIndex;

                ctx.strokeStyle = boxColor;
                ctx.lineWidth = isSelected ? 2 : 1;
                if (isSelected) {
                    ctx.setLineDash([8, 4]);
                    ctx.lineDashOffset = performance.now() / 200 % 12;
                } else {
                    ctx.setLineDash([]);
                }
                ctx.strokeRect(box.x, box.y, box.width, box.height);
                ctx.setLineDash([]);
                ctx.fillStyle = boxColor.replace('hsl', 'hsla').replace(')', ', ' + (isSelected ? 0.45 : 0.35) + ')');
                ctx.fillRect(box.x, box.y, box.width, box.height);
            });

            if (selectedBoxIndex >= 0) {
                const box = annotations[currentImageKey][selectedBoxIndex];
                const handles = getHandles(box);
                handles.forEach(handle => {
                    const halfSize = handleSize / 2;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, halfSize + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = getColorForClass(box.classId);
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, halfSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, halfSize, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }
        }

        function getColorForClass(classId) {
            const index = classes.indexOf(classId);
            const hue = (index * 137.508) % 360;
            return `hsl(${hue}, 100%, 50%)`;
        }

        function updateAnnotationList() {
            annotationList.innerHTML = '';
            if (!annotations[currentImageKey]) return;

            annotations[currentImageKey].forEach((box, index) => {
                const item = document.createElement('div');
                item.className = 'annotation-item';

                const image = images[currentImageKey];
                const centerX = (box.x + box.width / 2) / image.width;
                const centerY = (box.y + box.height / 2) / image.height;
                const normalizedWidth = box.width / image.width;
                const normalizedHeight = box.height / image.height;

                item.textContent = `${box.classId} ${centerX.toFixed(6)} ${centerY.toFixed(6)} ${normalizedWidth.toFixed(6)} ${normalizedHeight.toFixed(6)}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'btn btn-secondary';
                deleteBtn.style.padding = '4px 8px';
                deleteBtn.style.fontSize = '12px';
                deleteBtn.addEventListener('click', () => deleteBox(index));

                item.appendChild(deleteBtn);
                annotationList.appendChild(item);
            });
        }

        // Class Selection and Box Management
        function handleClassButtonClick(classId) {
            if (selectedBoxIndex >= 0) {
                const box = annotations[currentImageKey][selectedBoxIndex];
                saveState();
                box.classId = classId;
                saveAnnotations();
                updateAnnotationList();
                drawAnnotations();
                highlightClassButton(classId);
            } else {
                currentClass = classId;
                highlightClassButton(classId);
            }
        }

        function highlightClassButton(classId) {
            document.querySelectorAll('.class-btn').forEach(btn => {
                if (btn.dataset.class === classId) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        function selectBox(index) {
            selectedBoxIndex = index;
            if (index >= 0) {
                classLabel.textContent = 'Class of selected box';
                const box = annotations[currentImageKey][index];
                highlightClassButton(box.classId);
            } else {
                classLabel.textContent = 'Select class for new boxes';
                highlightClassButton(currentClass);
            }
            drawAnnotations();
        }

        function saveState() {
            if (currentImageKey) {
                const currentAnnotations = annotations[currentImageKey];
                history[currentImageKey].undoStack.push(JSON.parse(JSON.stringify(currentAnnotations)));
                history[currentImageKey].redoStack = [];
            }
        }

        function undo() {
            if (currentImageKey && history[currentImageKey].undoStack.length > 0) {
                const prevState = history[currentImageKey].undoStack.pop();
                history[currentImageKey].redoStack.push(JSON.parse(JSON.stringify(annotations[currentImageKey])));
                annotations[currentImageKey] = prevState;
                saveAnnotations();
                updateAnnotationList();
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(images[currentImageKey].element, 0, 0);
                drawAnnotations();
            }
        }

        function redo() {
            if (currentImageKey && history[currentImageKey].redoStack.length > 0) {
                const nextState = history[currentImageKey].redoStack.pop();
                history[currentImageKey].undoStack.push(JSON.parse(JSON.stringify(annotations[currentImageKey])));
                annotations[currentImageKey] = nextState;
                saveAnnotations();
                updateAnnotationList();
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(images[currentImageKey].element, 0, 0);
                drawAnnotations();
            }
        }

        function addBox(box) {
            if (currentImageKey) {
                saveState();
                annotations[currentImageKey].push(box);
                saveAnnotations();
                updateAnnotationList();
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(images[currentImageKey].element, 0, 0);
                drawAnnotations();
                updateImageList();
            }
        }

        function deleteBox(index) {
            if (currentImageKey && annotations[currentImageKey] && index >= 0 && index < annotations[currentImageKey].length) {
                saveState();
                annotations[currentImageKey].splice(index, 1);
                saveAnnotations();
                updateAnnotationList();
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(images[currentImageKey].element, 0, 0);
                drawAnnotations();
                updateImageList();
                selectedBoxIndex = -1;
            }
        }

        function deleteLastAnnotation() {
            if (currentImageKey && annotations[currentImageKey] && annotations[currentImageKey].length > 0) {
                deleteBox(annotations[currentImageKey].length - 1);
            }
        }

        function saveAnnotations() {
            if (currentImageKey) {
                localStorage.setItem('annotations_' + currentImageKey, JSON.stringify(annotations[currentImageKey]));
            }
        }

        // Export and Reset
        function exportAnnotations() {
            if (imageKeys.length === 0) {
                showNotification('No images to export!', 'error');
                return;
            }

            loadJSZip().then(() => {
                const zip = new JSZip();

                imageKeys.forEach((key) => {
                    let yoloText = '';
                    if (annotations[key]) {
                        const image = images[key];
                        annotations[key].forEach(box => {
                            const centerX = (box.x + box.width / 2) / image.width;
                            const centerY = (box.y + box.height / 2) / image.height;
                            const normalizedWidth = box.width / image.width;
                            const normalizedHeight = box.height / image.height;

                            yoloText += `${box.classId} ${centerX.toFixed(6)} ${centerY.toFixed(6)} ${normalizedWidth.toFixed(6)} ${normalizedHeight.toFixed(6)}\n`;
                        });
                    }

                    const txtFileName = key.replace(/\.[^/.]+$/, ".txt");
                    zip.file(txtFileName, yoloText);
                });

                const classesText = classes.map(id => `${id}: ${classNames[id]}`).join('\n');
                zip.file('classes.txt', classesText);

                zip.generateAsync({ type: 'blob' }).then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'yolo_annotations.zip';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showNotification('Annotations exported successfully!', 'success');
                });
            }).catch(error => {
                showNotification('Failed to load JSZip library. Please check your internet connection.', 'error');
                console.error('JSZip loading error:', error);
            });
        }

        function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (window.JSZip) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function reset() {
            if (confirm('Are you sure you want to reset all annotations? This cannot be undone.')) {
                for (let key in localStorage) {
                    if (key.startsWith('annotations_')) {
                        localStorage.removeItem(key);
                    }
                }
                annotations = {};
                history = {};
                selectedBoxIndex = -1;
                if (currentImageKey) {
                    annotations[currentImageKey] = [];
                    history[currentImageKey] = { undoStack: [], redoStack: [] };
                    updateAnnotationList();
                    ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                    ctx.drawImage(images[currentImageKey].element, 0, 0);
                    drawAnnotations();
                }
                showNotification('All annotations have been reset.', 'success');
            }
        }

        function showNotification(message, type) {
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 3000);
        }

        function handleKeyDown(e) {
            if (e.ctrlKey && e.key === 'z') {
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                redo();
            } else if (e.key === 'Delete' && selectedBoxIndex >= 0) {
                deleteBox(selectedBoxIndex);
                selectedBoxIndex = -1;
            } else if (e.shiftKey && e.code.startsWith('Digit')) {
                const digit = e.code.slice(-1);
                if (parseInt(digit) <= 9) {
                    handleClassButtonClick(digit);
                }
            } else if (e.altKey && e.code.startsWith('Digit')) {
                const digit = parseInt(e.code.slice(-1));
                const classIndex = 10 + digit;
                if (classIndex <= 10) {
                    handleClassButtonClick(classIndex.toString());
                }
            }
        }
    });
    </script>
</body>
</html>
